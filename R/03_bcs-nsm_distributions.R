#' @name bcsnsm.dist
#'
#' @title The Class of the Multivariate BCS-NSM Distributions 
#'
#' @description Joint probability density function
#'     and a random generator for the multivariate Box-Cox symmetric
#'     distributions generated by a normal scale mixture copula (BCS-NSM multivariate distributions).
#'
#' @param x vector or matrix of non-negative quantiles. If \code{x} is a matrix,
#'     each row is taken to be a quantile.
#' @param n number of replicates to return.
#' @param mu vector of the marginal scale parameters in \code{(0, infty)^d}, where \code{d} is the
#'     dimension.
#' @param sigma vector of the marginal relative dispersion parameters in \code{(0, infty)^d}, where \code{d} is the
#'     dimension.
#' @param lambda vector of the marginal skewness parameters in \code{R^d}, where \code{d} is the
#'     dimension.
#' @param nu vector of possible extra parameters of the marginal distributions. If a particular
#'     marginal distribution has no additional parameter, it must be necessarily specified with
#'     \code{NA} in that position.
#' @param Gamma the association matrix. It must be a positive-definite correlation matrix, default is
#'     \code{diag(ncol(x))} (the so-called non-associative association structure).
#' @param copula character; informs which normal scale mixture distribution
#'     should be used to generate the NSM copula. Currently,
#'     the copulas available are: Gaussian (\code{"gaussian"}),
#'     Student's t (\code{"t"}), slash (\code{"slash"}), and hyperbolic (\code{"hyp"}).
#' @param eta possible extra parameter induced by the copula, parameterized to take values at
#'     \code{(0, 1)}. For instance, under the \emph{t} copula, \code{eta} specifies
#'     \code{eta} / (1 - \code{eta}) degrees of freedom.
#' @param margins a character or a character vector; specifies the marginal BCS distributions. If all
#'     BCS margins are the same, it is sufficient to enter only one character. A table with the
#'     current available BCS distributions can be seen in \code{\link[bcsnsm]{bcs}}.
#' @param log logical; if \code{TRUE}, probabilities \code{p} are given
#'     as \code{log(p)}.
#'
#' @return \code{dbcsnsm} returns the evaluated joint density function and
#'      \code{rbcsnsm} generates random values.
#'
#' @details
#'     The BCS-NSM multivariate distributions consists of a broad class of models for positive
#'     continuous data with Box-Cox symmetric (BCS) marginal distributions, where a normal scale
#'     mixture (NSM) copula describes the dependence structure.
#'
#'     Let \eqn{\bold{Y} = (Y_1, \ldots, Y_n)'} be a vector of positive continuous random variables, where
#'     each \eqn{Y_j} follows a BCS distribution (not necessarily the same) for all
#'     \eqn{j = 1, \ldots , d}. We say that \eqn{\bold{Y}} follows a \emph{d}-variate
#'     BCS-NSM distribution if it has an NSM copula with association matrix \eqn{\bold{\Gamma}}
#'     (\code{Gamma}) and mixing cumulative distribution function (CDF) \eqn{H}.
#'
#'     The class of the BCS-NSM distributions includes models with various possibilities of marginal
#'     and dependence settings. For instance, each margin of \eqn{\bold{Y}} can follow a different
#'     BCS distribution. This property provides the BCS-NSM distributions the flexibility to 
#'     accommodate random vectors whose marginal distributions have different behaviors, such as 
#'     different types of skewness and tail-heaviness.
#'
#'     The NSM copula is characterized by the mixing CDF \eqn{H}. For instance, if \eqn{H} is the
#'     CDF of a random variable \eqn{W} degenerate at \eqn{w = 1}, then \eqn{\bold{Y}} has a Gaussian
#'     copula. If \eqn{H} is the CDF of a random variable \eqn{W} with an inverse gamma distribution
#'     with both parameters equal to \eqn{\delta/2}, \eqn{\delta > 0}, then \eqn{\bold{Y}} has a
#'     \emph{t} copula with \eqn{\delta} degrees of freedom. In the \code{bcsnsm} package, we consider
#'     the parameterization \code{eta = delta / (1 + delta)}.
#'     
#'     
#'     Because copulas are invariant under strictly increasing transformations,
#'     copula-based measures of association of the scale mixtures of normal distributions are the
#'     same for the BCS-NSM distributions. This statement is valid for measures of concordance, such
#'     as Kendall's tau or the tail dependence coefficients. Let \eqn{\gamma_{ij}} be the element of
#'     the \emph{i}th row and \emph{j}th column of the association matrix \eqn{\bold{\Gamma}}, where
#'     \eqn{\gamma_{ii} = 1}, for \emph{i, j = 1, ..., d}. Thus, Kendall's tau of \eqn{Y_i} and 
#'     \eqn{Y_j} is given by
#'
#'     \deqn{\tau(Y_i, Y_j) = \dfrac{2 \; \textrm{asin}(\gamma_{ij})}{\pi},}
#'
#'     and it is invariant under the copula. Since Kendallâ€™s tau is a
#'     rank correlation coefficient, it measures any monotonous association between two random variables.
#'     Thus, we have an increasing monotonous association between \eqn{Y_i} and \eqn{Y_j} when \eqn{\gamma_{ij}}
#'     is close to \eqn{1}, and a decreasing monotonous association when \eqn{\gamma_{ij}} is close to \eqn{-1}.
#'     Furthermore, \eqn{\gamma_{ij} = 0} indicates no monotonous association. These facts show that
#'     the association matrix \eqn{\bold{\Gamma}} plays an essential role in specifying the dependence
#'     structure of \eqn{\bold{Y}}. It can be parameterized in terms of a real-valued vector \eqn{\gamma}
#'     in an interpretative way depending on the type of association that is of interest to describe.
#'
#'
#' @references
#'
#'  Vanegas, L. H., and Paula, G. A. (2016). Log-symmetric distributions:
#'      statistical properties and parameter estimation. \emph{Brazilian Journal of
#'      Probability and Statistics}, 30, 196--220.
#'
#'  Ferrari, S. L. P., and Fumes, G. (2017). Box-Cox symmetric distributions and
#'      applications to nutritional data. \emph{AStA Advances in Statistical Analysis},
#'      101, 321--344.
#'
#' @examples
#' # Sample size and dimension
#' n <- 500
#' d <- 4
#'
#' ### Marginal specifications
#'
#' # Marginal distributions
#' margins <- c("bct", "bcloi", "bcpe", "bcno")
#'
#' # Marginal parameters
#' mu <- c(13, 20, 15, 10)
#' sigma <- c(0.1, 0.3, 0.4, 0.2)
#' lambda <- c(-2, 3, 1, -0.5)
#' nu <- c(2, NA, 8, NA)
#'
#' ### Dependence specifications
#'
#' # Copula
#' copula <- "slash"
#'
#' # Extra parameter
#' eta <- 0.75
#'
#' # Association matrix
#' tau <- 0.6
#' gamma <- sin(0.5 * pi * tau)
#' Gamma <- matrix(gamma, d, d)
#' diag(Gamma) <- 1
#'
#' ### Generating observations
#' set.seed(1)
#' x <- rbcsnsm(n, mu, sigma, lambda, nu, Gamma, copula, eta, margins)
#'
#' ### Visualization with mvplot() (see ?mvplot for documentation)
#' mvplot(x)
#'
#' @author Rodrigo M. R. de Medeiros <\email{rodrigo.matheus@live.com}>
#'

# Joint density ------------------------------------------------------------------------------------
#' @rdname bcsnsm.dist
#' @export
dbcsnsm <- function(x, mu, sigma, lambda, nu = NULL, Gamma = diag(ncol(x)),
                    copula = c("gaussian", "t", "slash", "hyp"),
                    eta = NULL, margins = "bcno", log = FALSE) {

  ### Setting dimensions
  if (is.vector(x))
    x <- matrix(x, ncol = length(x))

  n <- dim(x)[1]
  d <- dim(x)[2]

  ### Marginal parameters
  mu <- matrix(mu, ncol = d)
  sigma <- matrix(sigma, ncol = d)
  lambda <- matrix(lambda, ncol = d)
  aux_nu <- as.numeric(stats::na.exclude(nu))

  mu <- do.call(rbind, replicate(n / dim(mu)[1], mu, simplify = FALSE))
  sigma <- do.call(rbind, replicate(n / dim(sigma)[1], sigma, simplify = FALSE))
  lambda <- do.call(rbind, replicate(n / dim(lambda)[1], lambda, simplify = FALSE))

  margins <- as.vector(matrix(margins, 1, d))

  nu <- rep(NA, d)
  nu_id <- apply(matrix(margins, ncol = 1), 1, function(x) as.bcs(x)$extrap)
  nu[nu_id] <- aux_nu

  ### Copula
  copula <- match.arg(copula, c("gaussian", "t", "slash", "hyp"))
  if (!is.null(eta)) {
    if (eta <= 0 | eta >= 1)
      stop("eta must be a value on (0, 1)")
  }

  mcopula <- make_copula(copula, eta / (1 - eta))

    dgf <- mcopula$dgf
  qPSI <- mcopula$qPSI

  EPS <- .Machine$double.eps^(1 / 2)
  w <- log_f <- matrix(NA, n, d)
  for (j in 1:d) {

    w[, j] <- pmin(pmax(get(paste0("p", margins[j]), envir = asNamespace("bcsnsm"))(q = x[, j],
                                                     mu = mu[, j],
                                                     sigma = sigma[, j],
                                                     lambda = lambda[, j],
                                                     nu = nu[j]), EPS), 1 - EPS)

    log_f[, j] <- get(paste0("d", margins[j]), envir = asNamespace("bcsnsm"))(x = x[, j],
                                               mu = mu[, j],
                                               sigma = sigma[, j],
                                               lambda = lambda[, j],
                                               nu = nu[j], log = TRUE)

  }

  epsilon <- matrix(qPSI(w), ncol = d)
  dec <- Rfast::cholesky(Gamma)

  tmp <- backsolve(dec, t(epsilon), transpose = TRUE)
  rss <- colSums(tmp^2)

  den <- -sum(log(diag(dec))) + dgf(rss, d, log = TRUE) -
    rowSums(matrix(dgf(epsilon^2, 1L, log = TRUE), ncol = d)) + rowSums(log_f)

  if (log) {
    den
  } else {
    exp(den)
  }
}

# Random generation --------------------------------------------------------------------------------
#' @rdname bcsnsm.dist
#' @export
rbcsnsm <- function(n, mu, sigma, lambda, nu, Gamma = diag(ncol(x)),
                   copula = c("gaussian", "t", "slash", "hyp"),
                   eta = NULL, margins = "bcno") {
  d <- ncol(Gamma)

  ### Marginal parameters
  mu <- matrix(mu, ncol = d)
  sigma <- matrix(sigma, ncol = d)
  lambda <- matrix(lambda, ncol = d)

  mu <- do.call(rbind, replicate(n / dim(mu)[1], mu, simplify = FALSE))
  sigma <- do.call(rbind, replicate(n / dim(sigma)[1], sigma, simplify = FALSE))
  lambda <- do.call(rbind, replicate(n / dim(lambda)[1], lambda, simplify = FALSE))
  aux_nu <- as.numeric(stats::na.exclude(nu))

  margins <- as.vector(matrix(margins, 1, d))

  nu <- rep(NA, d)
  nu_id <- apply(matrix(margins, ncol = 1), 1, function(x) as.bcs(x)$extrap)
  nu[nu_id] <- aux_nu

  ## Sampling from NSM distribution
  copula <- match.arg(copula, c("gaussian", "t", "slash", "hyp"))
  if (!is.null(eta)) {
    if (eta <= 0 | eta >= 1)
      stop("eta must be a value on (0, 1)")
  }

  mcopula <- make_copula(copula, eta / (1 - eta))

  epsilon <- mcopula$rmv(n, Gamma)

  w <- matrix(mcopula$pPSI(epsilon), ncol = d)

  ## Sampling for the multivariate distribution
  x <- matrix(NA, n, d)
  for (j in 1:d) {

    x[, j] <- get(paste0("q", margins[j]), envir = asNamespace("bcsnsm"))(p = w[, j],
                                           mu = mu[, j],
                                           sigma = sigma[, j],
                                           lambda = lambda[, j],
                                           nu = nu[j])
  }

  if (n == 1) x <- as.numeric(x)
  colnames(x) <- paste0("x", 1:d)
  x
}


# Comparative plot function ------------------------------------------------------------------------
#' Visualize Multivariate Data
#'
#' This function takes a matrix of quantitative data and generates a panel plot.
#' The diagonal panels contains histograms for each variable, the lower panels
#' display pairwise scatter plots, and the upper panels show some association
#' measure, such as Kendall's tau, Spearman's rho, or Pearson correlation coefficient.
#'
#' @param y a matrix or a data frame of quantitative data with variables in columns.
#' @param method a character string indicating which association coefficient
#'    is to be computed for the upper panels of the plot. It is computed
#'    via [cor](stats::cor) function. One of \code{"kendall"} (default),
#'    \code{"pearson"}, or \code{"spearman"} can be used.
#' @param ... arguments to be passed to or from methods.
#'
#' @return A panel plot displaying histograms on the diagonal, scatterplots in the
#' lower panels, and Kendall's tau correlation in the upper panels.
#'
#' @export
#'
#' @author Rodrigo M. R. de Medeiros <\email{rodrigo.matheus@live.com}>
#'
#' @examples
#' data <- data.frame(x1 = rnorm(1000),
#'                    x2 = rgamma(1000, 2, 4),
#'                    x3 = rbeta(1000, 4, 1),
#'                    x5 = rlnorm(1000, 3, 0.5))
#'
#' mvplot(data)
mvplot <- function(y, method = c("kendall", "spearman", "pearson"), ...) {

  method <- match.arg(method, c("kendall", "spearman", "pearson"))

  if (requireNamespace("ggplot2", quietly = TRUE) &
      requireNamespace("GGally", quietly = TRUE)) {

    if (method == "kendall") {
      method_name <- "Kendall's tau"
    } else if (method == "spearman") {
      method_name <- "Spearman's rho"
    } else if (method == "pearson") {
      method_name <- "Linear correlation"
    }

    # Defines function to color according to correlation
    cor_func <- function(data, mapping, ...){

      x <- GGally::eval_data_col(data, mapping$x)
      y <- GGally::eval_data_col(data, mapping$y)

      corr <- stats::cor(x, y, method = method, use = 'complete.obs')

      colFn <- grDevices::colorRampPalette(c("brown1", "white", "dodgerblue"), interpolate ='spline')
      fill <- colFn(1000)[findInterval(corr, seq(-1, 1, length = 1000))]

      GGally::ggally_text(
        label = as.character(round(corr, 4)),
        mapping = ggplot2::aes(),
        xP = 0.5, yP = 0.5,
        cex = 2.5,
        color = 'black', ...) +
        ggplot2::theme_void() +
        ggplot2::theme(panel.background = ggplot2::element_rect(fill = fill))
    }


    u <- stats::runif(200, -1, 1)
    u[which.min(u)] <- -1
    u[which.max(u)] <- 1
    colFn <- grDevices::colorRampPalette(c("brown1", "white", "dodgerblue"), interpolate ='spline')
    lab <- ggplot2::ggplot(data.frame(x = u, y = u, z = u), ggplot2::aes(x, y, colour = z)) +
      ggplot2::geom_point() +
      ggplot2::scale_colour_gradient2(method_name,
                                      low = colFn(200)[1], high = colFn(200)[200]) +
      ggplot2::theme(legend.title.align = 0.5,
                     legend.position = "top",
                     legend.key.height = ggplot2::unit(0.3, 'cm'),
                     legend.key.width = ggplot2::unit(1.5, 'cm'))


    GGally::ggpairs(as.data.frame(y),
                    #lower = list(continuous = "points", combo = "facethist", discrete = "facetbar"),
                    lower = list(continuous = GGally::wrap("points", size = 1.2)),
                    upper = list(continuous = GGally::wrap(cor_func)),
                    diag = list(continuous = GGally::wrap("barDiag",
                                                          colour = 1,
                                                          fill = "white",
                                                          bins = ceiling(1 + 3.33 * log(nrow(y))) )),
                    progress = FALSE)

  } else {

    ## put histograms on the diagonal
    panel.hist <- function(x, ...) {

      usr <- graphics::par("usr")
      on.exit(graphics::par(usr = usr))
      h <- graphics::hist(x, plot = FALSE)
      breaks <- h$breaks
      nB <- length(breaks)
      y <- h$density
      graphics::par(usr = c(usr[1:2], 0, max(y) + 0.5 * diff(range(y))))
      graphics::rect(breaks[-nB], 0, breaks[-1], y, col = "white", ...)

    }

    ## put an association measure on the upper panels
    panel.cor <- function(x, y, ...) {

      usr <- graphics::par("usr")
      on.exit(graphics::par(usr = usr))

      r <- stats::cor(x, y, method = method)

      colFn <- grDevices::colorRampPalette(c("brown1", "white", "dodgerblue"), interpolate = "spline")
      fill <- colFn(1000)[findInterval(r, seq(-1, 1, length = 1000))]

      graphics::par(usr = c(0, 1, 0, 1))
      txt <- format(c(r, 0.123456789), digits = 2)[1]
      txt <- paste0(txt)
      graphics::rect(0, 0, 1, 1, col = fill, border = "black")
      graphics::text(0.5, 0.5, txt, cex = 1.2)

    }

    ## put scatterplots with countour lines on the lower panels
    panel.scatter <- function(x, y, ...) {

      usr <- graphics::par("usr")
      on.exit(graphics::par(usr = usr))
      graphics::points(x, y, pch = 16, cex = 0.8)

    }

    graphics::pairs(y, lower.panel = panel.scatter, upper.panel = panel.cor, diag.panel = panel.hist,
                    labels = colnames(y), cex.labels = 1.1, font.labels = 2)


  }


}

globalVariables(c("x", "z"))
